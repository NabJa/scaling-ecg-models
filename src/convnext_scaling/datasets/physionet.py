import os
from pathlib import Path
from typing import Optional

import numpy as np
import pandas as pd
import torch
from lightning import LightningDataModule
from skmultilearn.model_selection import IterativeStratification
from tqdm import tqdm

from scaling.augmentations import ECGAugmentation

# Evaluation weights for all classes
WEIGHTS = pd.read_csv(
    "https://raw.githubusercontent.com/physionetchallenges/evaluation-2021/refs/heads/main/weights.csv",
    index_col=0,
)

# Mapping between SNOMED codes and the corresponding classes
DX_SCORED = pd.read_csv(
    "https://raw.githubusercontent.com/physionetchallenges/evaluation-2021/refs/heads/main/dx_mapping_scored.csv"
)
DX_SCORED["IndexU"] = list(DX_SCORED.index)

# Some snomed codes are treated as equivalent in PhysioNet.
EQUIVALENCE_MAP = {
    733534002: 164909002,
    713427006: 59118001,
    284470004: 63593006,
    427172004: 17338001,
}

# List of classes that are scored in the challenge
CLASSES = [
    {"164889003"},
    {"164890007"},
    {"6374002"},
    {"426627000"},
    {"164909002", "733534002"},
    {"59118001", "713427006"},
    {"270492004"},
    {"713426002"},
    {"39732003"},
    {"445118002"},
    {"164947007"},
    {"251146004"},
    {"111975006"},
    {"698252002"},
    {"426783006"},
    {"284470004", "63593006"},
    {"10370003"},
    {"365413008"},
    {"17338001", "427172004"},
    {"164917005"},
    {"47665007"},
    {"427393009"},
    {"426177001"},
    {"427084000"},
    {"164934002"},
    {"59931005"},
]

# SnomedCT code for sinus rhythm. Used for the challenge metric.
SINUS_RYTHM = set(["426783006"])

# Mapping between the index and the label
LABEL_MAP = {
    0: "AF",
    1: "AFL",
    2: "BBB",
    3: "Brady",
    4: "CLBBB, LBBB",
    5: "CRBBB, RBBB",
    6: "IAVB",
    7: "IRBBB",
    8: "LAD",
    9: "LAnFB",
    10: "LQRSV",
    11: "NSIVCB",
    12: "NSR",
    13: "PAC",
    14: "PR, SVPB",
    15: "PRWP",
    16: "PVC",
    17: "LPR, VPB",
    18: "LQT",
    19: "QAb",
    20: "RAD",
    21: "SA",
    22: "SB",
    23: "STach",
    24: "TAb",
    25: "TInv",
}


def remove_dx_equivalence(df):
    """Updates the IndexU column in the DataFrame to remove equivalence between SNOMED codes."""

    df = df.copy()
    df["IndexU"] = np.nan
    for key, value in EQUIVALENCE_MAP.items():
        query = (df.SNOMEDCTCode == key).argmax()
        df.loc[df.SNOMEDCTCode == value, "IndexU"] = float(query)

    _unchanged = df.IndexU.isna()
    df.loc[_unchanged, "IndexU"] = np.arange(_unchanged.sum())
    df.IndexU = df.IndexU.astype(int)
    return df


class PhysioNet:
    """Dataset class for the PhysioNet 2021 Challenge."""

    def __init__(
        self,
        meta_file_path,
        *,
        ecg_transform=None,
        fold="all",
        remove_quivalent_labels=True,
    ):
        """
        Args:
            meta_file_path (str): Path to the meta csv file. Generated by our preprocessing script in scaling/preprocessing/physionet/physionet.py.
            ecg_transform (callable, optional): Transform(s) to apply to the ECG signal.
            fold (int, str): Fold to use. Can be "all", "train", "test" or an integer in [0, 1, 2, 3].
            remove_quivalent_labels (bool): If True, removes the equivalence between some SNOMED codes. As described in the PhysioNet documentation.
        """
        self.meta = pd.read_csv(meta_file_path)
        self.meta = self.meta.dropna(how="all")
        self.meta = self.meta.reset_index(drop=True)

        self.ecg_transform = ecg_transform
        self.fold = fold

        # Label mapping
        self.dx_map = (
            remove_dx_equivalence(DX_SCORED) if remove_quivalent_labels else DX_SCORED
        )
        self.nlabels = self.dx_map.IndexU.nunique()

        # Optionally generate folds and select the desired fold.
        if "Fold" not in self.meta.columns:
            self.generate_folds()
        self.meta = self.select_fold(fold)

    def __len__(self):
        return len(self.meta)

    def __getitem__(self, index):
        sample = self.meta.iloc[index]

        label = self.get_label(sample)
        ecg = self.get_ecg(sample)

        return ecg, label

    def select_fold(self, fold):
        """Returns the samples for the given fold."""
        if fold == "all":
            return self.meta
        if fold == "train":
            return self.meta[self.meta.Fold != 3]
        if fold == "test":
            return self.meta[self.meta.Fold == 3]
        if isinstance(fold, int):
            assert 0 <= fold < 4, "Fold must be in [0, 1, 2, 3]"
            return self.meta[self.meta.Fold == fold]
        if isinstance(fold, list):
            return self.meta[self.meta.Fold.isin(fold)]

    def get_label(self, sample):
        """Returns one-hot encoded label for the given index."""

        return self.one_hot(*eval(sample.dx))

    def get_ecg(self, sample):
        """Returns the ECG signal for the given index. Apply transformation if specified."""

        ecg: torch.Tensor = torch.load(sample.filepath, weights_only=False)
        if self.ecg_transform is not None:
            ecg = self.ecg_transform(ecg)
        return ecg.float()

    def one_hot(self, *snomed_codes):
        """Returns a one-hot encoded tensor for the given SNOMED codes."""

        indeces = self.dx_map.loc[
            self.dx_map.SNOMEDCTCode.isin(snomed_codes), "IndexU"
        ].values
        one_hot = torch.zeros(self.nlabels)
        if len(indeces) == 0:
            return one_hot
        one_hot[torch.tensor(indeces)] = 1
        return one_hot

    def index_to_label(self, index, label_col="Abbreviation"):
        """Returns the SNOMED code for the given index."""
        labels = self.dx_map.loc[self.dx_map.IndexU == index, label_col].values
        return ", ".join(labels)

    def generate_folds(self):
        """
        Generates 4 folds. First three are 30% of the data and used for 3-fold cross-validation.
        The last fold is 10% of the data and used for testing.
        The folds are stratified using a iterative stratification for multi-labels (http://scikit.ml/stratification.html).
        We stritify based on the labels and the dataset to ensure that the same amount of samples comes from every dataset.
        """

        # Extract all labels in the dataset
        with tqdm(
            self.meta.iterrows(), total=len(self.meta), desc="Preparing folds"
        ) as spbar:
            y = torch.stack([self.get_label(sample) for _, sample in spbar])

        def _filepath_to_dataset(path):
            """Extract the dataset name from the file path."""
            return Path(path).parents[1].name

        # One-hot encode the dataset source and add it to the labels.
        dataset_label = pd.get_dummies(
            self.meta.original_filepath.apply(_filepath_to_dataset)
        )
        dataset_label = dataset_label.astype(int).to_numpy()
        y = np.concat([y, dataset_label], axis=1)

        # Multi-label stratification.
        k_fold = IterativeStratification(
            n_splits=4, order=3, sample_distribution_per_fold=[0.3, 0.3, 0.3, 0.1]
        )

        # Save folds to the meta DataFrame.
        self.meta["Fold"] = -1
        for i, (_, test_idx) in enumerate(k_fold.split(self.meta, y)):
            self.meta.loc[test_idx, "Fold"] = i


class PhysionetDM(LightningDataModule):
    def __init__(
        self,
        meta_file_path: str,
        train_transform: ECGAugmentation,
        val_transform: ECGAugmentation,
        fold: int = 0,
        batch_size: int = 32,
        remove_quivalent_labels: bool = True,
        num_workers: Optional[int] = None,
    ):
        """
        Args:
            meta_file_path (str): Path to the meta csv file. Generated by our preprocessing script in scaling/preprocessing/physionet/physionet.py.
            fold (int, optional): Validation fold to use. Must be in [0, 1, 2]. Defaults to 0.
            train_transform (ECGAugmentation, optional): Transformations for training.
            val_transform (ECGAugmentation, optional): Transformations for validation.
            batch_size (int, optional): Batch sizze. Defaults to 32.
            remove_quivalent_labels (bool, optional): Removes labels that are scored the same in pyhsionet. Defaults to True.
        """
        super().__init__()

        assert fold in [0, 1, 2], "Fold must be in [0, 1, 2]"

        self.meta_file_path = meta_file_path
        self.batch_size = batch_size
        self.remove_quivalent_labels = remove_quivalent_labels

        self.valid_fold = fold

        self.train_transform = train_transform
        self.val_transform = val_transform

        self.num_workers = os.cpu_count() if num_workers is None else num_workers

        self.save_hyperparameters()

    def setup(self, stage=None):
        self.test_fold = 3
        self.train_folds = [0, 1, 2]
        self.train_folds.remove(self.valid_fold)

        self.train = PhysioNet(
            self.meta_file_path,
            ecg_transform=self.train_transform,
            fold=self.train_folds,
            remove_quivalent_labels=self.remove_quivalent_labels,
        )
        self.valid = PhysioNet(
            self.meta_file_path,
            ecg_transform=self.val_transform,
            fold=self.valid_fold,
            remove_quivalent_labels=self.remove_quivalent_labels,
        )

    def train_dataloader(self):
        return torch.utils.data.DataLoader(
            self.train,
            batch_size=self.batch_size,
            shuffle=True,
            drop_last=True,
            num_workers=self.num_workers,
            pin_memory=True,
        )

    def val_dataloader(self):
        return torch.utils.data.DataLoader(
            self.valid,
            batch_size=self.batch_size,
            shuffle=False,
            num_workers=self.num_workers,
        )
